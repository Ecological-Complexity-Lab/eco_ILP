---
title: "results"
output: 
  html_document:
    fig.width: 12
    fig.height: 8
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: true
---

<style>
.specialheader {
   color:orange !important;
}
</style>


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F, results = "show", message=FALSE, warning=FALSE, cache=TRUE, eval = TRUE, out.width = '100%', out.height='40%')
```

# Initializie

## Import libraries
```{r libraries}
library(tidyverse)
library(ggpubr)
library(ggtext)
library(magrittr)
library(pROC)
library(PRROC)
library(dplyr)
library(reshape2)
library(stringr)
library(RColorBrewer)
library(cowplot)
library(dunn.test)
```

## Set important variables
```{r set_variable}
# Define a color palette 
communities_colors <- c("Plant-Pollinator" = "#CCEBC5", 
                   "Host-Parasite" = "#FBB4AE", 
                   "Plant-Seed Dispersers" = "#B3CDE3",
                   "Plant-Herbivore" = "#c2bcff")

communities_colors_dark <- c("All" = "Orange",
                        "Plant-Pollinator" = "#82CE70", 
                        "Host-Parasite" = "#F65143", 
                        "Plant-Seed Dispersers" = "#659AC6",
                        "Plant-Herbivore" = "#c3b5ff")

metrics_colors <- c("balanced_accuracy" = "#F8766D",
                      "roc_auc" = "#C49A00", 
                      "pr_auc" = "#53B400", 
                      "precision" = "#00C094",
                      "recall"="#00B6EB",
                      "specificity"="#A58AFF",
                      "f1"="#FB61D7")

metrics_labels <- tibble(metric=c('balanced_accuracy','recall','precision','f1','mcc','specificity', 'roc_auc', 'pr_auc'),
                         metric_label=c('BA',               'Recall','Precision','F1','MCC','Specificity', 'ROC AUC', 'PR AUC'))

                         

# Set a threshold
threshold <- 0.5 

# Choose whether to export figures and tables
export = F

# Folders
path_main_dir = "/gpfs0/shai/users/barryb/link-predict/" # Path of the main folder
setwd(path_main_dir) # Set working dir

path_metadata = paste0(path_main_dir, "data/processed/") # Path of proccessed networks & features data, serving as complementary metadata
path_raw_results = paste0(path_main_dir, "results/raw/") # Path of raw results
path_intermediate_results = paste0(path_main_dir, "results/intermediate/") # Path of intermediate results, output of this script
path_final_results = paste0(path_main_dir, "results/final/") # Path of final results, output of this script

```

## Define the plots' theme
```{r def_plot_them}
# The size of the font is relative to the size of the figure. You can change it here.
fontsize <- 14

paper_figs_theme <- 
  theme_bw()+
  theme(panel.grid = element_blank(),
        panel.border = element_rect(color = "black",fill = NA,linewidth = 1),
        panel.spacing = unit(0.5, "cm", data = NULL),
        axis.text = element_text(size=fontsize, color='black'),
        axis.title = element_text(size=fontsize, color='black'),
        axis.line = element_blank(), 
        legend.text=element_text(size=fontsize-2, color='black'),
        legend.title=element_text(size=fontsize, color='black'))

paper_figs_theme_no_legend <- 
  paper_figs_theme +
  theme(legend.position = 'none')
```

# Exploratory Data Analysis

## Features distributions
```{r}

# Load the features dataframe
network_lvl_features <- read.csv(paste0(path_intermediate_results, "network_lvl_features.csv"))

# Create a list of the communities to be used
filter_list <- c("Plant-Pollinator", "Host-Parasite", "Plant-Seed Dispersers", "Plant-Herbivore")

# Long format features daatframe
network_lvl_features_long <- 
  network_lvl_features %>%
  filter(community %in% filter_list) %>%
  select(subsample_ID, community, network_size, interactions_count, connectance, links.per.species) %>%
  rename('average degree' = links.per.species) %>%
  pivot_longer(cols = c('network_size', 'interactions_count', 'connectance', 'average degree'), names_to = "feature", values_to = "value") #, -community

# # Create a boxplot for each feature
# features_dist_plot <- ggplot(network_lvl_features_long, aes(x = community, y = value, fill = community)) +
#   geom_boxplot() +
#   facet_wrap(~ feature, ncol = 5, scales = "free") +
#   theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
#   scale_fill_manual(values = communities_colors) +
#   labs(x = "Community", y = "Value") #, title = "Boxplots for each feature by community"

# # Display the plot
# print(features_dist_plot)

# Plot number of data sets
dataset_counts <- 
  network_lvl_features  %>%
  filter(community%in%c('Plant-Seed Dispersers', 'Plant-Pollinator', 'Plant-Herbivore', 'Host-Parasite')) %>% 
  group_by(community) %>% 
  summarise(n=n_distinct(subsample_ID))

dataset_counts_plot <- 
  ggplot(dataset_counts, aes(x = "", y = n, fill = community)) +
  geom_bar(width = 1, stat = "identity", color = "white") +
  coord_polar("y", start = 0) +
  theme_void() +
  labs(title = "Community Interactions") +
  theme(legend.title = element_blank(),
        axis.text = element_blank()) +
  scale_fill_brewer(palette = "Pastel1")

# Display the plot
#print(dataset_counts_plot)

# Save to file
if (export){
  png(paste(path_final_results,'SI_dataset_counts_plot.png', sep = ""), width = 10,height = 5,units = 'in', res = 600)
  print(dataset_counts_plot)
  dev.off()
}

# Some means
network_lvl_features  %>%
  filter(community%in%c('Plant-Seed Dispersers', 'Plant-Pollinator', 'Plant-Herbivore', 'Host-Parasite')) %>% 
  summarise(mean_size=mean(connectance))


# Create a histogram for each feature
features_hist_plot <- ggplot(network_lvl_features_long, aes(x = value, fill = community)) +
  geom_histogram(position = "dodge") +
  facet_grid(community ~ feature, scales = "free") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_fill_manual(values = communities_colors) +
  labs(x = "Value", y = "Count")

# Display the plot
#print(features_hist_plot)

# Save to file
if (export){
  png(paste(path_final_results,'SI_features_hist.png', sep = ""), width = 10,height = 5,units = 'in', res = 600)
  print(features_hist_plot)
  dev.off()
}
```

## Summarize across networks

```{r}
features_hist_all_nets <- 
network_lvl_features_long %>% 
  mutate(feature=factor(feature, 
                        levels=c("network_size","interactions_count", "connectance","average degree" ))) %>% 
  # filter(feature=='connectance') %>% 
  ggplot(aes(x = value)) +
  geom_histogram(position = "dodge", fill = '#147274') +
  facet_grid(~feature, scales = "free") +
  theme(legend.position = 'none',axis.text.x = element_text(angle = 45, hjust = 1)) +
  paper_figs_theme_no_legend+
  # scale_fill_manual(values = communities_colors) +
  labs(x = "Value", y = "Count")

#print(features_hist_all_nets)

# Save to file
if (export){  
  png(paste(path_final_results,'SI_features_hist_all_nets.png', sep = ""), width = 10,height = 5,units = 'in', res = 600)
  print(features_hist_all_nets)
  dev.off()
}
```

## PCA

```{r}
# Load the dataframe
pca_df <- read.csv(paste0(path_intermediate_results, "pca_df.csv"))

# Plot
pca_plot <- ggplot(pca_df, aes(x = PC2, y = PC1, color = community)) +
  geom_point(size=2) +
  labs(x = "PC1", y = "PC2", color='Community') +
  scale_color_manual(values = communities_colors_dark) +
  paper_figs_theme+
  theme(legend.position = c(0.2,0.2))

# Display the plot
#print(pca_plot)


if(export){
  pdf(paste(path_final_results,'SI_networks_PCA.pdf', sep = ""), 7, 7)
  print(pca_plot)
  dev.off()
}
```

# Model evaluation

## Distributions of evaluation metrics: All communities

```{r}
# Load the dataframe
metrics_df_long <- 
  read_csv(paste0(path_intermediate_results, "metrics_df_long.csv")) %>% 
  left_join(metrics_labels) %>% 
  select(-metric) %>% 
  rename(metric=metric_label) %>% 
  mutate(metric=factor(metric, levels = c('BA', 'Recall', 'Precision', 'F1', 'MCC', 'Specificity', 'ROC AUC', 'PR AUC')))
```

### Combine Data Points from all folds into Single Boxplots
```{r fig_4}
# Plot
metrics_plot <- 
  ggplot(metrics_df_long, aes(x = metric, y = value)) +
  geom_boxplot(show.legend=F, fill='#675fe1') +
  geom_hline(yintercept = 0, linetype='dashed')+
  # ylim(0, 1) +
  stat_summary(fun = mean, geom = "point", shape = 18, size = 4, color = "black", show.legend=F) +
  scale_fill_manual(values = metrics_colors) +
  labs(y = "Metric Value", x = "Metric") +
  paper_figs_theme

# Display the plot
#print(metrics_plot)

# Save to file
if (export){
  png(paste(path_final_results,'eval_all.png', sep = ""), width = 10,height = 5,units = 'in', res = 600)
  print(metrics_plot)
  dev.off()
}

```

### Figure SI_metrics_by_folds :One boxplot per fold
```{r}
# Plot
metrics_nCV_plot <- 
  ggplot(metrics_df_long, aes(x = metric, y = value, color = factor(fold))) +
  geom_boxplot(alpha = 0.6, show.legend=F) +
  geom_hline(yintercept = 0, linetype='dashed')+
  stat_summary(fun = mean, geom = "point", shape = 18, size = 4, color = "black", show.legend=F) +
  labs(y = "Metric Value") +
  facet_wrap(~ community) + 
  paper_figs_theme +
  theme(axis.text.x = element_text(angle = 45, hjust=1),
        axis.title.x = element_blank())

#print(metrics_nCV_plot)

if(export){
  pdf(paste(path_final_results,'SI_metrics_by_folds', sep = ""), 16, 9)
  print(metrics_nCV_plot)
  dev.off()
}
```

## Figure 5 -Distributions of per community evaluation metrics

```{r fig.height = 5, fig.width = 8}
metrics_comm_plot <- 
  metrics_df_long %>% 
  ggplot(aes(x = metric, y = value, fill = community)) +
  geom_boxplot() +
  ylim(0, 1) +
  scale_fill_manual(values = communities_colors) +
  labs(y = "Metric value", x = "Metric", fill='Community') +
  ylim(c(-0.3,1))+
  paper_figs_theme + 
  theme(legend.position = 'top',
        axis.title.x = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1,
                                   face = ifelse(levels(metrics_df_long$metric) %in% c('BA', 'ROC AUC'), 'plain', 'bold'),
                                   colour = ifelse(levels(metrics_df_long$metric) %in% c('BA', 'ROC AUC'), 'black', '#4B994B')))

# Display the plot
#print(metrics_comm_plot)

# Get median values
metrics_df_long %>% 
  # fill na values with 0
  mutate(value = ifelse(is.na(value), 0, value)) %>%
  group_by(community, metric) %>% 
  summarise(median_value = median(value)) %>% 
  spread(metric, median_value)

# Save to file
if(export){
  pdf(paste(path_final_results,'communities.pdf', sep = ""), 10, 5)
  print(metrics_comm_plot)
  dev.off()
}

```

## ROC & PR cruves
```{r}

# Load the dataframes with fold information
roc_df <- read.csv(paste0(path_intermediate_results, "roc_df.csv"))
pr_df <- read.csv(paste0(path_intermediate_results, "pr_df.csv"))
auc_df <- read.csv(paste0(path_intermediate_results, "auc_df.csv"))

# Calculate mean AUC for each community
auc_summary <- auc_df %>%
  group_by(community) %>%
  summarise(mean_ROC_auc = mean(ROC_auc, na.rm = TRUE),
            mean_PR_auc = mean(PR_auc, na.rm = TRUE)) %>%
  ungroup() %>% 
  rowwise() %>% 
  mutate(ROC_label= paste0(community, " (AUC: ", round(mean_ROC_auc, 2), ")")) %>%  # Create labels for the legend that include the AUC values
  mutate(PR_label= paste0(community, " (AUC: ", round(mean_PR_auc, 2), ")"))

# Create a mapping between the original and new labels
roc_label_mapping <- setNames(auc_summary$ROC_label, auc_summary$community)
pr_label_mapping <- setNames(auc_summary$PR_label, auc_summary$community)

```

## <span class="specialheader">Figure 3 - ROC-PR curves</span>
```{r}
# Plotting
roc_plot <- ggplot(roc_df, aes(x = fpr, y = tpr, group = community)) +
  geom_line(aes(color = community)) +
  # geom_ribbon(aes(ymin = mean_tpr - sd_tpr, ymax = mean_tpr + sd_tpr, fill = community), alpha = 0.1) + # Range
  annotate("segment", x = 0, xend = 1, y = 0, yend = 1, color="red", linetype="dashed") +
  coord_equal() +
  labs(x = "False Positive Rate (1 - Specificity)", y = "True Positive Rate (Sensitivity)") +
  scale_color_manual(values = communities_colors_dark,
                    labels = roc_label_mapping) +
  scale_fill_manual(values = communities_colors_dark) +
  paper_figs_theme

#print(roc_plot)

if(export){
  pdf(paste(path_final_results,'roc_curve.pdf', sep = ""), 10, 5)
  print(roc_plot)
  dev.off()
}

pr_plot <- ggplot(pr_df, aes(x = recall, y = precision, group = community)) +
  geom_line(aes(color = community)) +
    # geom_ribbon(aes(ymin = mean_precision - sd_precision, ymax = mean_precision + sd_precision, fill = community), alpha = 0.1) +
  coord_equal() +
  labs(x = "Recall", y = "Precision") +
  scale_color_manual(values = communities_colors_dark,
                    labels = pr_label_mapping) +
  scale_fill_manual(values = communities_colors_dark) +
  paper_figs_theme

#print(pr_plot)

if(export){
  pdf(paste(path_final_results,'pr_curve.pdf', sep = ""), 10, 5)
  print(pr_plot)
  dev.off()
}
```

### Precision-Recall tradeoff as a function of classification threshold

```{r}
# Set labels
new_names <- c(
              'All' = "A. All communities",
              "Host-Parasite" = "B. Host-Parasite",
              "Plant-Pollinator" = "C. Plant-Pollinator",
              "Plant-Seed Dispersers" = "D. Plant-Seed Dispersers",
              "Plant-Herbivore" = "E. Plant-Herbivore"
              )
```

### <span class="specialheader">Figure SI_PR_tradeoff</span>
```{r}

pr_tradeoff_plot <- ggplot(pr_df, aes(x = threshold)) +
    geom_line(aes(y = precision, color = "Precision"), linetype = "solid") +
    geom_line(aes(y = recall, color = "Recall"), linetype = "solid") +
    geom_line(aes(y = f1, color = "F1 Score"), linetype = "solid") +
    scale_color_manual(values = c("Precision" = "#E06A5A", "Recall" = "#99008C", "F1 Score" = "#EACA00")) +
    labs(x = "Threshold", y = "Precision/Recall score", color = "Metric") +
    paper_figs_theme +
    facet_wrap(~community, labeller = as_labeller(new_names)) +
    theme(axis.text.x=element_text(angle=-45, hjust=0))

# Display the plot
print(pr_tradeoff_plot)

if(export){
  pdf(paste(path_final_results,'SI_PR_tradeoff.pdf', sep = ""), 16, 9)
  print(pr_tradeoff_plot)
  dev.off()
}

```

## Distribution of link probabilities: all communities

```{r load_data}

# Load the dataframe
test_data <- read.csv(paste0(path_intermediate_results, "test_data.csv"))

```

```{r}
# Set labels
labels_mapping <- c(
              "Non-existing Links" = "A. Non-existing Links",
              "Subsampled Links" = "B. Subsampled Links",
              "Host-Parasite" = "A. Host-Parasite",
              "Plant-Pollinator" = "B. Plant-Pollinator",
              "Plant-Seed Dispersers" = "C. Plant-Seed Dispersers",
              "Plant-Herbivore" = "D. Plant-Herbivore"
              )

# Plot the distribution with subplots
proba_dist_plot <- test_data %>%
  mutate(class = ifelse(y_true >= 0.5, "Subsampled Links", "Non-existing Links")) %>% # Create a new column to categorize the data based on the threshold
  ggplot(aes(x = y_proba)) +
    geom_histogram(binwidth = 0.05, alpha = 0.8, fill = "steelblue", color = "white") +
    # geom_vline(aes(xintercept = 0.5, xmin = 0, color = "red"), linetype = "dashed") +
    geom_segment(aes(x = 0.5, xend = 0.5, y = 0, yend = Inf, color = "Threshold"), linetype = "dashed") +	
    scale_color_manual(name = "", values = c("Threshold" = "red"), labels = c("Threshold" = "threshold=0.5")) +	
    labs(x = "Probability", y = "Frequency", color = "legend") + #title = "Distribution of the predicted probabilities", 
    paper_figs_theme_no_legend +
    facet_wrap(~ class, nrow = 1, scales = "free_y", labeller = as_labeller(labels_mapping)) +
    theme(plot.margin = unit(c(0.2,0.4,0.2,0.2), "cm"))
    #theme(strip.text = element_text(face = "bold")) # Change labels to bold
   
# Display the plot
print(proba_dist_plot)

# How many links classified?
test_data %>%
  mutate(class = ifelse(y_true >= 0.5, "Subsampled Links", "Non-existing Links")) %>%
  group_by(class) %>%
  summarise(
    count_condition = sum(if_else(class == "Subsampled Links", y_proba > 0.5, y_proba < 0.5), na.rm = TRUE),
    total = n(),
    proportion = count_condition / total
  )

# Save to file
if (export){  
  png(paste(path_final_results,'SI_probabilities.png', sep = ""), width = 10,height = 5,units = 'in', res = 600)
  print(proba_dist_plot)
  dev.off()
}
```

## Distribution (density) of link probabilities: per community
```{r}
# Plot
proba_dist_community_plot <- test_data %>%
  mutate(class = ifelse(y_true >= 0.5, "Subsampled Links", "Non-existing Links")) %>%
  ggplot(aes(x = y_proba, fill = class)) +
    geom_density(alpha = 0.5) +
    # geom_histogram(binwidth = 0.05, color = "white", alpha = 0.5, position = 'identity') +
    geom_vline(aes(xintercept = 0.5), color = "red", linetype = "dashed") +
    labs(x = "Probability", y = "Density") +
    scale_fill_manual(values = c("Non-existing Links" = "steelblue", "Subsampled Links" = "orange"), labels = labels_mapping) +
    facet_wrap(~ community, labeller = as_labeller(labels_mapping)) +
    paper_figs_theme +
    theme(legend.title = element_blank(),
          axis.text.x=element_text(angle=-45, hjust=0))

# Display the plot
print(proba_dist_community_plot)

# Save to file
if (export){
  png(paste(path_final_results,'SI_community.png', sep = ""), width = 10,height = 5,units = 'in', res = 600)
  print(proba_dist_community_plot)
  dev.off()
}
```

## Network Predictions Heatmap

```{r fig_2, fig.width=12, fig.height=8}

# Load the dataframe
df_pred_heatmap <- read.csv(paste0(path_intermediate_results, "df_pred_heatmap.csv"))

# Create a version of colors with transparency
color_mapping_linktypes <- 
  c("correct" = "#00BF7D", 
    "wrong" = "#F8766D"#, 
    # "neutral" = "black"
    )
# color_mapping_linktypes_transparent <- alpha(color_mapping_linktypes, alpha = 0.8)

# plot heatmap
predictions_heatmap <- ggplot(df_pred_heatmap, aes(x = lower_level, y = higher_level, fill = value)) +
  geom_tile(aes(color = correct_prediction, width = 0.95, height = 0.95), size = 1.25, alpha = 0.8) +
  geom_point(data = subset(df_pred_heatmap, is_FN), aes(color = correct_prediction), size = 11 , shape = 4, stroke = 1.5) +
  # scale_fill_gradient(low = "#56B1F7", high = "#132B43") +
  # scale_fill_gradient(low = "white", high = "steelblue") +
  scale_fill_gradientn(colors = brewer.pal(8, "Blues")) +
  scale_color_manual(values = color_mapping_linktypes) +
  labs(x = "Lower Level", y = "Higher Level", fill = "Predicted Probability") +
  paper_figs_theme +
  geom_text(aes(label = round(value, 2)), size = 4) +
  theme(axis.text.x = element_text(angle = -35, hjust = 0))

# Display the plot
print(predictions_heatmap)

# Save to file
if (export){
  png(paste(path_final_results,'predictions.png', sep = ""), width = 10,height = 5,units = 'in', res = 600)
  print(predictions_heatmap)
  dev.off()
}
```

## Compare models

```{r}

# Load the dataset
metrics_multi_df_long <- read.csv(paste0(path_intermediate_results, "metrics_multi_df_long.csv"))

# Plot
models_compare_plot <- ggplot(metrics_multi_df_long, aes(x = metric, y = value, fill = model)) +
  geom_col(position = "dodge2", width = 0.7) +
  # facet_wrap(~ metric, scales = "free_y", ncol = 1) +
  labs(y = "Value", fill = "Model") +
  paper_figs_theme +
  theme(legend.position = "bottom",
        axis.title.x = element_blank(),
        plot.margin = unit(c(0.2,1,0.2,0.2), "cm"))

# Display the plot
print(models_compare_plot)

# Save to file
if (export){
  png(paste(path_final_results,'SI_models.png', sep = ""), width = 10,height = 5,units = 'in', res = 600)
  print(models_compare_plot)
  dev.off()
}

```

## Features importance

Prepare data:

```{r}
models_name_mapper <- c("Random Forest" = "RandomForestClassifier",
                        "Logistic Regression" = "LogisticRegression",
                        "XGBoost" = "XGBClassifier"#,
                        # "ANN" = "BayesianOptimization"
                        )

models_order <- names(models_name_mapper)

```

### Features importance - single model

```{r}
feature_importance <- read.csv(paste0(path_raw_results, "feature_importance_nCV.csv"))
```

```{r fig.width=10, fig.height=6}

# Prepare the dataframe
feature_importance_long <- 
  feature_importance %>%
  filter(model == "RandomForestClassifier") %>%
  # mutate(importance = abs(importance)) %>% # Convert importance to absolute values
  group_by(feature, model) %>% # Group by feature - when there are folds
  summarise(importance_mean = mean(importance),
            importance_min = min(importance),
            importance_max = max(importance)) %>%
  ungroup() %>%
  top_n(15, abs(importance_mean)) %>% # Select top n features for each model
  arrange(importance_mean)

# Convert feature to factor and specify the levels
feature_importance_long$feature <- factor(feature_importance_long$feature, levels = feature_importance_long$feature)

# Create a feature importance plot
importance_plot <- ggplot(feature_importance_long, aes(feature, importance_mean, fill = model)) +
  geom_col(show.legend = FALSE) +
  geom_errorbar(aes(ymin = importance_min, ymax = importance_max), width = 0.2) +
  coord_flip() +
  labs(y = "Mean Importance", x = "Feature") + # no need for units in the X axis?
  paper_figs_theme

# Display the plot
print(importance_plot)

# Save to file
if (export){
  png(paste(path_final_results,'importance_pres.png', sep = ""), width = 10,height = 5,units = 'in', res = 600)
  print(importance_plot)
  dev.off()
}
```

### <span class="specialheader">Figure 4 - Feature importance</span>
```{r}
# Create a feature importance plot
importance_plot <- 
  ggplot(feature_importance_long, aes(feature, importance_mean, fill = model)) +
  geom_col(show.legend = FALSE) +
  geom_errorbar(aes(ymin = importance_min, ymax = importance_max), width = 0.2) +
  scale_fill_manual(values = 'light blue')+
  coord_flip() +
  labs(y = "Mean Importance", x = "Feature") + # no need for units in the X axis?
  paper_figs_theme

if(export){
  pdf(paste(path_final_results,'feature_importance.pdf', sep = ""), 10, 5)
  print(importance_plot)
  dev.off()
}
```



### Features importance - multiple models
```{r  fig.width=10, fig.height=6}
models_name_mapper <- c("Random Forest" = "RandomForestClassifier",
                        "Logistic Regression" = "LogisticRegression",
                        "XGBoost" = "XGBClassifier"#,
                        # "ANN" = "BayesianOptimization"
                        )

models_order <- names(models_name_mapper)

# Prepare the dataframe
feature_importance_long_models <- 
  feature_importance %>%
  mutate(model = recode(model, !!!as.list(setNames(names(models_name_mapper), models_name_mapper)))) %>% # rename values
  mutate(importance = abs(importance)) %>% # Convert Importance to absolute values
  group_by(feature, model) %>%
  summarise(importance_mean = mean(importance),
            importance_min = min(importance),
            importance_max = max(importance)) %>%
  ungroup() %>%
  slice_max(n=10, by=model, order_by=abs(importance_mean)) %>%
  arrange(importance_mean) %>%
  mutate(feature = factor(paste(feature, model, sep = "__"), 
                          levels = rev(paste(feature, model, sep = "__"))),
         model = factor(model, levels = models_order)) # solves reording within facets

# Convert feature to factor and specify the levels
feature_importance_long_models$feature <- factor(feature_importance_long_models$feature, levels = feature_importance_long_models$feature)

# Create a feature importance plot
importance_multi_plot <- ggplot(feature_importance_long_models, aes(feature, importance_mean, fill = model)) +
  geom_col(show.legend = FALSE) +
  geom_errorbar(aes(ymin = importance_min, ymax = importance_max), width = 0.2) +
  coord_flip() +
  facet_wrap(~ model, scales = "free", ncol = 2, nrow = 2) +
  labs(y = "Mean Importance", x = "Feature") +
  paper_figs_theme +
  theme(axis.text.x = element_text(angle = -35, hjust = 0)) + 
  scale_x_discrete(labels = function(x) gsub("__.+$", "", x)) # reverse the renaming

# Display the plot
print(importance_multi_plot)

if (export){
  png(paste(path_final_results,'SI_importance.png', sep = ""), width = 10,height = 5,units = 'in', res = 600)
  print(importance_multi_plot)
  dev.off()
} 
```

# Inter-community predictions: 

## Plot v1
```{r fig_6}
# Function to create custom facet labels
custom_labeler <- function(labels, var) {
  sapply(labels, function(label) {
    
    # Parse the label to extract individual community names
    label_list <- unlist(strsplit(gsub("^\\[|\\]$|'", "", label), split = ",\\s*"))

    # # Get the number of observations for the current facet
    # n <- ifelse(var == "type_train", sum(train_networks$community %in% label_list),
    #                                       sum(test_networks$community %in% label_list))
    
    # Map label to comm_names
    label <- comm_names[[label]]

    # Return the label with the number of observations
    # paste0(label, "\n(n=", n, ")")
  })
}

# Load the dataset
metrics_type_df_long <- read.csv(paste0(path_intermediate_results, "metrics_type_df_long.csv"))


# Mapping original community names to simpler names
comm_names <- c(
              "['Host-Parasite']" = "Host-\nParasite",
              "['Plant-Pollinator']" = "Plant-\nPollinator",
              "['Plant-Seed Dispersers']" = "Plant-\nSeed Dispersers",
              "['Plant-Herbivore']" = "Plant-\nHerbivore",
              "['Plant-Seed Dispersers', 'Plant-Pollinator', 'Plant-Herbivore', 'Host-Parasite']" = "All\nEcological",
              "['Plant-Seed Dispersers', 'Plant-Herbivore', 'Host-Parasite']"  = "Ecological w/o\nPollinator",
              "['Chicago']" = "Chicago",
              "['San Francisco']" = "San Francisco",
              "['Minneapolis']" = "Minneapolis",
              "['Minneapolis', 'Chicago', 'San Francisco']" = "All\nCrime",
              "['Legislature']"  = "Legislature"
              )

# Custom order for type_train and type_test
custom_order <- c("['Plant-Seed Dispersers', 'Plant-Pollinator', 'Plant-Herbivore', 'Host-Parasite']", "['Host-Parasite']", "['Plant-Herbivore']", "['Plant-Pollinator']", "['Plant-Seed Dispersers']",  "['Plant-Seed Dispersers', 'Plant-Herbivore', 'Host-Parasite']", "['Minneapolis', 'Chicago', 'San Francisco']", "['San Francisco']", "['Chicago']", "['Minneapolis']", "['Legislature']")

# Applying the custom order
metrics_type_df_long$type_train <- factor(metrics_type_df_long$type_train, levels = custom_order)
metrics_type_df_long$type_test <- factor(metrics_type_df_long$type_test, levels = custom_order)

# Set colors
library(dplyr)

# Assuming metrics_type_df_long is your original dataframe
# and ecological_networks contains the ecological network types based on type_train indices
ecological_networks <- c("['Plant-Herbivore']", 
                         "['Plant-Pollinator']", 
                         "['Plant-Seed Dispersers', 'Plant-Pollinator', 'Plant-Herbivore', 'Host-Parasite']", 
                         "['Plant-Seed Dispersers', 'Plant-Herbivore', 'Host-Parasite']",
                         "['Host-Parasite']", 
                         "['Plant-Seed Dispersers']")

metrics_type_df_long <- metrics_type_df_long %>%
  mutate(
    color = case_when(
      type_train %in% ecological_networks & type_test %in% ecological_networks ~ "ecological",
      !type_train %in% ecological_networks & !type_test %in% ecological_networks ~ "non-ecological",
      type_train %in% ecological_networks & !type_test %in% ecological_networks ~ "ecological_to_non",
      !type_train %in% ecological_networks & type_test %in% ecological_networks ~ "non_to_ecological"
    )
  )


type_compare_plot <- ggplot(metrics_type_df_long, aes(x = metric, y = value, fill = color)) +
  geom_boxplot(show.legend=F) +
  paper_figs_theme +
  scale_y_continuous(breaks = c(0,0.5,1)) + 
  stat_summary(fun = mean, geom = "point", shape = 18, size = 4, color = "black", show.legend=F) +
  labs(y = "Metric Value", x = "Metric") +
  scale_fill_manual(values = c("ecological" = "#228B22", "non-ecological" = "blue", "ecological_to_non" = "purple", "non_to_ecological" = "orange")) +
  theme(axis.text.x = element_text(angle = -25, hjust = 0),
        strip.text = element_text(size = 14)) +
  facet_grid(
    cols = vars(type_train), 
    rows = vars(type_test),
    labeller = labeller(
      type_train = function(labels) custom_labeler(labels, "type_train"),
      type_test = function(labels) custom_labeler(labels, "type_test")
    )
  )

# Print the plot
print(type_compare_plot)

# Save to file
if (export){
  png(paste(path_final_results,'split_set.png', sep = ""), width = 10,height = 5,units = 'in', res = 600)
  print(type_compare_plot)
  dev.off()
}
```

##  <span class="specialheader">Figure 6 - Cross-community prediction</span>


```{r}

labels <- c("['Plant-Herbivore']",
            "['Plant-Pollinator']",
            "['Plant-Seed Dispersers', 'Plant-Pollinator', 'Plant-Herbivore', 'Host-Parasite']",
            "['Plant-Seed Dispersers', 'Plant-Herbivore', 'Host-Parasite']", 
            "['Host-Parasite']",
            "['Plant-Seed Dispersers']")

# Remove unwanted characters
clean_labels <- gsub("\\['|'\\]", "", labels)

# Replace level 3 with "all"
clean_labels[3] <- "All"
clean_labels[4] <- "No PP"

metrics_type_df_long_f1 <- 
  metrics_type_df_long %>% 
  as_tibble() %>% 
  filter(color=='ecological') %>% 
  filter(metric %in% c('f1')) %>%
  mutate(metric=factor(metric, levels=c('f1'), labels=c('F1'))) %>%
  mutate(type_train=gsub("\\['|'\\]", "", type_train)) %>% 
  mutate(type_test=gsub("\\['|'\\]", "", type_test)) %>% 
  mutate(type_train = case_when(type_train == "Plant-Seed Dispersers', 'Plant-Pollinator', 'Plant-Herbivore', 'Host-Parasite" ~ "All",
                                type_train == "Plant-Seed Dispersers', 'Plant-Herbivore', 'Host-Parasite" ~ "No PP",
                                type_train == 'Plant-Seed Dispersers' ~ 'PSD',
                                type_train == 'Plant-Pollinator' ~ 'PP',
                                type_train == 'Plant-Herbivore' ~ 'PH',
                                type_train == 'Host-Parasite' ~ 'HP')) %>% 
  mutate(type_test = case_when(type_test == "Plant-Seed Dispersers', 'Plant-Pollinator', 'Plant-Herbivore', 'Host-Parasite" ~ "All",
                                type_test == "Plant-Seed Dispersers', 'Plant-Herbivore', 'Host-Parasite" ~ "No PP",
                                type_test == 'Plant-Seed Dispersers' ~ 'PSD',
                                type_test == 'Plant-Pollinator' ~ 'PP',
                                type_test == 'Plant-Herbivore' ~ 'PH',
                                type_test == 'Host-Parasite' ~ 'HP')) %>% 
  mutate(type_train = factor(type_train, levels=c("All", "No PP", "HP", "PSD", "PH", "PP"))) %>% 
  mutate(type_test = factor(type_test, levels=c("All", "No PP", "HP", "PSD", "PH", "PP")))
         
library(ggtext)

cross_community_f1 <-   
  metrics_type_df_long_f1 %>%
  group_by(type_train, type_test, metric) %>%
  summarise(m = median(value, na.rm = TRUE)) %>%
  mutate(diagonal = ifelse(type_train == type_test, "Diagonal", "Non-Diagonal")) %>%
  ggplot(aes(x = type_train, y = type_test, fill = m)) +
  geom_tile(color='white', lwd = 1.5, linetype = 1) +
  scale_fill_viridis_c() +
  coord_fixed() +
  paper_figs_theme +
  geom_tile(data = . %>% filter(diagonal == "Diagonal"), color = '#C66AC4', lwd = 3, linetype = 1, size = 3) +
  labs(y = "Test community", x = "Train community", fill = "Median F1") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))+
  geom_richtext(aes(label = round(m, 2)),
                fill = 'white',
                label.padding = unit(0.1, "lines"),
                text.colour = "black",
                fontface = "bold",
                label.colour = "black")


# A version with box plots
# cross_community_f1 <-   
#   ggplot(metrics_type_df_long_f1, aes(x = type_train, y = value, fill=type_train)) +
#   geom_boxplot() +
#   paper_figs_theme +
#   # scale_y_continuous(breaks = c(0,0.25,0.5,1)) +
#   scale_fill_manual(values=c('orange',unname(communities_colors)))+
#   # stat_summary(fun = mean, geom = "point", shape = 18, size = 4, color = "black", show.legend=F) +
#   labs(y = "F1 value", fill = "Training community") +
#   theme(legend.position = 'bottom',
#         axis.title.x = element_blank(),
#         axis.text.x = element_blank(),
#         axis.ticks = element_blank(),
#         strip.text = element_text(size = 14))+
#   facet_grid(
#     cols = vars(type_test),
#     labeller = labeller(
#       type_test = function(labels) custom_labeler(labels, "type_test")
#     ), scales = 'free_y'
#   )+
#   geom_segment(data = subset(metrics_type_df_long_f1, metric == "F1" & type_test == "['Plant-Seed Dispersers']" & type_train == "Plant-Pollinator"),
#                aes(x = 2.5, xend = 2, y = 0.43, yend = 0.33), 
#                colour = "red", size = 1, 
#                arrow = arrow(length = unit(0.3, "cm"))) 

print(cross_community_f1)

if (export){
  pdf(paste(path_final_results,'cross_community_prediction.pdf', sep = ""), 10, 6)
  print(cross_community_f1)
  dev.off()
}

```



# Compare (our) inductive to transductive LP models

```{r}

# Load the dataset
compare_models_metrics_df = read.csv(paste0(path_intermediate_results, 'compare_other_models_metrics_df.csv'))

```

## <span class="specialheader">Figure 2 - Compare (our) inductive to transductive LP models</span>
```{r}
ILP_vs_TLP <- 
  compare_models_metrics_df %>% 
  as_tibble() %>% 
  mutate(model=ifelse(model=='Random Forest (same type)','ILP (same community)',model)) %>% 
  mutate(model=ifelse(model=='Random Forest (all types)','ILP (all communities)',model)) %>% 
  filter(metric %in% metrics_labels$metric) %>% 
  mutate(metric = factor(metric, levels = metrics_labels$metric, labels =  metrics_labels$metric_label)) %>%
  mutate(model = factor(model, 
                        levels = c('ILP (same community)','ILP (all communities)','ML_single','Connectance','SBM','Ensamble'),
                        labels = c('ILP (same community)','ILP (all communities)','TLP','Connectance','SBM','Ensemble'))) %>%
  filter(model %in% c('ILP (all communities)','TLP','SBM', 'Connectance')) %>%
  ggplot(aes(x = metric, y = value, fill=model, color=model)) +
  geom_boxplot(show.legend=T, color='black') +
  # ylim(0, 1) +
  # stat_summary(fun = mean, geom = "point", shape = 18, size = 4, show.legend=F) +
  scale_fill_manual(values = c('orange','#861ea5','gray50','gray')) +
  labs(y = "Metric value", x = "Metric") +
  paper_figs_theme +
  theme(legend.position = c(0.87,0.2),
        legend.title = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1),
        axis.title.x = element_blank()) # Rotating x-axis labels 45 degrees

print(ILP_vs_TLP)

if(export){
  pdf(paste(path_final_results,'ILP_vs_TLP.pdf', sep = ""), 10, 5)
  print(ILP_vs_TLP)
  dev.off()
}
```

# Bounds of the metrics

## <span class="specialheader">Figure 7 - model bounuds</span>

```{r}
# Load the dataset
bounds_summary_df <- read.csv(paste0(path_intermediate_results, "bounds_summary_df.csv"))

custom_labels <- c(
  "recall" = "Recall",
  "f1" = "F1",
  "specificity" = "Specificity",
  "mcc" = "MCC",
  "pr_auc" = "PR AUC",
  "precision" = "Precision",
  "roc_auc" = "ROC AUC"
)


# Plotting
bounds_plot <- 
  bounds_summary_df %>% 
  filter(metric != 'mcc') %>% 
  ggplot(aes(x = fraction)) +
  geom_ribbon(aes(ymin = ci_lower_lower_bound, ymax = ci_upper_lower_bound), fill = "#cbdcec") +  # Plot bounds as a ribbon with CI
  geom_ribbon(aes(ymin = ci_lower_upper_bound, ymax = ci_upper_upper_bound), fill = "#cbdcec") +  # Plot bounds as a ribbon with CI
  geom_line(aes(y = avg_lower_bound), color = "blue", linetype = "dashed") +  # Plot average lower bound
  geom_line(aes(y = avg_upper_bound), color = "blue", linetype = "dashed") +  # Plot average upper bound
  geom_ribbon(aes(ymin = ci_lower_fixed, ymax = ci_upper_fixed), fill = "#f4a582", alpha = 0.5) +  # CI for fixed_value
  geom_line(aes(y = avg_fixed_value), color = "red") +  # Plot average fixed value
  facet_wrap(~ metric, scales = 'free_y', labeller = as_labeller(custom_labels)) +  # Create a separate panel for each metric with custom labels
  scale_x_continuous(breaks = seq(0.05, 0.5, by = 0.1), limits = c(0.05, 0.5)) +  # Set x axis limits and breaks
  labs(x = 'Fraction of true missing links', y='Metric value')+
  geom_segment(data = subset(bounds_summary_df, metric == "recall"),
               aes(x = 0.3, xend = 0.15, y = 0.8, yend = 0.8), 
               colour = "red", size = 1, 
               arrow = arrow(length = unit(0.3, "cm")))+
  paper_figs_theme

# Display the plot
print(bounds_plot)

if(export){
  pdf(paste(path_final_results,'model_bounds.pdf', sep = ""), 10, 10)
  print(bounds_plot)
  dev.off()
}
```

```{r}
# Load the dataset
bounds_summary_df_transductive <- read.csv(paste0(path_intermediate_results, "bounds_summary_df_transductive.csv"))

# Plotting
bounds_plot_transductive <- 
  bounds_summary_df_transductive %>% 
  filter(metric != 'mcc') %>% 
  ggplot(aes(x = fraction)) +
  geom_ribbon(aes(ymin = ci_lower_lower_bound, ymax = ci_upper_lower_bound), fill = "#cbdcec") +  # Plot bounds as a ribbon with CI
  geom_ribbon(aes(ymin = ci_lower_upper_bound, ymax = ci_upper_upper_bound), fill = "#cbdcec") +  # Plot bounds as a ribbon with CI
  geom_line(aes(y = avg_lower_bound), color = "blue", linetype = "dashed") +  # Plot average lower bound
  geom_line(aes(y = avg_upper_bound), color = "blue", linetype = "dashed") +  # Plot average upper bound
  geom_ribbon(aes(ymin = ci_lower_fixed, ymax = ci_upper_fixed), fill = "#f4a582", alpha = 0.5) +  # CI for fixed_value
  geom_line(aes(y = avg_fixed_value), color = "red") +  # Plot average fixed value
  facet_wrap(~ metric, scales = 'free_y', labeller = as_labeller(custom_labels)) +  # Create a separate panel for each metric with custom labels
  scale_x_continuous(breaks = seq(0.05, 0.5, by = 0.1), limits = c(0.05, 0.5)) +  # Set x axis limits and breaks
  labs(x = 'Fraction of true missing links', y='Metric value')+
  # geom_segment(data = subset(bounds_summary_df_transductive, metric == "recall"),
  #              aes(x = 0.3, xend = 0.15, y = 0.8, yend = 0.8), 
  #              colour = "red", size = 1, 
  #              arrow = arrow(length = unit(0.3, "cm")))+
  paper_figs_theme

# Display the plot
print(bounds_plot_transductive)

# if(export){
# pdf(paste(path_final_results,'model_bounds_transductive.pdf', sep = ""), 10, 10)
# print(bounds_plot_transductive)
# dev.off()
# }
```

## Combine ILP and TLP bounds

```{r}
merics_for_lot <- c("recall",'f1','specificity')
bounds_ILP_TLP_plot <- 
as_tibble(
bind_rows(
  bounds_summary_df_transductive %>% filter(metric %in% merics_for_lot) %>% mutate(model='TLP'),
  bounds_summary_df %>% filter(metric %in% merics_for_lot) %>% mutate(model='ILP')
)) %>% 
  # mutate((metric=factor(metric, levels=c("recall",'f1',"specificity",'mcc')))) %>% 
  mutate(across(metric, ~factor(., levels=merics_for_lot))) %>% 
  ggplot(aes(x = fraction)) +
  geom_line(aes(y = avg_fixed_value, color = model), linetype = "dashed") +  # Plot average fixed value
  geom_line(aes(y = avg_lower_bound, color = model)) +  # Plot average lower bound
  geom_line(aes(y = avg_upper_bound, color = model)) +  # Plot average upper bound
  geom_ribbon(aes(ymin = ci_lower_lower_bound, ymax = ci_upper_lower_bound, fill = model), alpha=0.1) +  # Plot bounds as a ribbon with CI
  geom_ribbon(aes(ymin = ci_lower_upper_bound, ymax = ci_upper_upper_bound, fill = model), alpha=0.1) +  # Plot bounds as a ribbon with CI
  # geom_ribbon(aes(ymin = ci_lower_fixed, ymax = ci_upper_fixed), fill = "#f4a582", alpha = 0.5) +  # CI for fixed_value
  facet_wrap(~ metric,  labeller = as_labeller(custom_labels)) +  # Create a separate panel for each metric with custom labels
  scale_x_continuous(breaks = seq(0.05, 0.5, by = 0.1), limits = c(0.05, 0.5)) +  # Set x axis limits and breaks
  labs(x = 'Fraction of true missing links', y='Metric value', fill='Model', color='Model')+
  scale_color_manual(values = c('orange','#861ea5')) +
  scale_fill_manual(values = c('orange','#861ea5')) +
  geom_segment(data = . %>% filter(metric == "recall"),
               aes(x = 0.2, xend = 0.15, y = 0.8, yend = 0.8), 
               colour = "red", size = 1, 
               arrow = arrow(length = unit(0.3, "cm")))+
  geom_segment(data = . %>% filter(metric == "recall"),
               aes(x = 0.2, xend = 0.15, y = 0.62, yend = 0.62), 
               colour = "red", size = 1, 
               arrow = arrow(length = unit(0.3, "cm")))+
  paper_figs_theme

if(export){
  pdf(paste(path_final_results,'model_bounds_ILP_TLP.pdf', sep = ""), 10, 6)
  print(bounds_ILP_TLP_plot)
  dev.off()
}
```

# Plots for the paper



## Figure 1 - Pipeline
Done externally






## Figure SI_ILP_vs_TLP_community - Compare (our) inductive to transductive LP models per community
```{r}
ILP_vs_TLP_community <- 
  compare_models_metrics_df %>% 
  as_tibble() %>% 
  mutate(model=ifelse(model=='Random Forest (same type)','ILP (same community)',model)) %>% 
  mutate(model=ifelse(model=='Random Forest (all types)','ILP (all communities)',model)) %>% 
  filter(metric %in% metrics_labels$metric) %>% 
  mutate(metric = factor(metric, levels = metrics_labels$metric, labels =  metrics_labels$metric_label)) %>%
  mutate(model = factor(model, 
                        levels = c('ILP (same community)','ILP (all communities)','ML_single','Connectance','SBM','Ensamble'),
                        labels = c('ILP (same community)','ILP (all communities)','TLP','Connectance','SBM','Ensemble'))) %>%
  filter(model %in% c('ILP (all communities)','TLP','SBM', 'Connectance')) %>%
  ggplot(aes(x = metric, y = value, fill=model, color=model)) +
  geom_boxplot(show.legend=T, color='black') +
  facet_wrap(~community)+
  scale_fill_manual(values = c('orange','#861ea5','gray50','gray')) +
  labs(y = "Metric value", x = "Metric") +
  paper_figs_theme +
  theme(legend.position = 'top',
        legend.title = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1),
        axis.title.x = element_blank()) # Rotating x-axis labels 45 degrees


if(export){
  pdf(paste(path_final_results,'ILP_vs_TLP_community.pdf', sep = ""), 12, 12)
  print(ILP_vs_TLP_community)
  dev.off()
}
```


## Figure SI_predictions

```{r}
# plot heatmap
predictions_heatmap <- ggplot(df_pred_heatmap, aes(x = lower_level, y = higher_level, fill = value)) +
  geom_tile(aes(color = correct_prediction, width = 0.95, height = 0.95), size = 1.25, alpha = 0.8) +
  geom_point(data = subset(df_pred_heatmap, is_FN), aes(color = correct_prediction), size = 11 , shape = 4, stroke = 1.5) +
  # scale_fill_gradient(low = "#56B1F7", high = "#132B43") +
  # scale_fill_gradient(low = "white", high = "steelblue") +
  scale_fill_gradientn(colors = brewer.pal(8, "Blues")) +
  scale_color_manual(values = color_mapping_linktypes) +
  labs(x = "Lower Level", y = "Higher Level", fill = "Predicted Probability") +
  paper_figs_theme +
  geom_text(aes(label = round(value, 2)), size = 4) +
  theme(axis.text.x = element_text(angle = -35, hjust = 0))

if(export){
  pdf(paste(path_final_results,'SI_predictions.pdf', sep = ""), 16, 9)
  print(predictions_heatmap)
  dev.off()
}
```


## Figure SI_models
```{r}
models_compare_plot <- 
  metrics_multi_df_long %>% 
  mutate(model = replace(model, model == "Voting", "Average")) %>% 
  ggplot(aes(x = metric, y = value, fill = model)) +
  geom_col(position = "dodge2", width = 0.7) +
  # facet_wrap(~ metric, scales = "free_y", ncol = 1) +
  labs(y = "Value", fill = "Model") +
  paper_figs_theme +
  theme(legend.position = "bottom",
        axis.title.x = element_blank(),
        plot.margin = unit(c(0.2,1,0.2,0.2), "cm"))

if(export){
  pdf(paste(path_final_results,'SI_models.pdf', sep = ""), 16, 9)
  print(models_compare_plot)
  dev.off()
}
```

## Figure SI_probabilities
```{r}
proba_dist_plot <- test_data %>%
  mutate(class = ifelse(y_true >= 0.5, "Subsampled Links", "Non-existing Links")) %>% # Create a new column to categorize the data based on the threshold
  ggplot(aes(x = y_proba)) +
    geom_histogram(binwidth = 0.05, alpha = 0.8, fill = "steelblue", color = "white") +
    # geom_vline(aes(xintercept = 0.5, xmin = 0, color = "red"), linetype = "dashed") +
    geom_segment(aes(x = 0.5, xend = 0.5, y = 0, yend = Inf, color = "Threshold"), linetype = "dashed") +	
    scale_color_manual(name = "", values = c("Threshold" = "red"), labels = c("Threshold" = "threshold=0.5")) +	
    labs(x = "Probability", y = "Frequency", color = "legend") + #title = "Distribution of the predicted probabilities", 
    paper_figs_theme_no_legend +
    facet_wrap(~ class, nrow = 1, scales = "free_y", labeller = as_labeller(labels_mapping)) +
    theme(plot.margin = unit(c(0.2,0.4,0.2,0.2), "cm"))
    #theme(strip.text = element_text(face = "bold")) # Change labels to bold

if(export){
  pdf(paste(path_final_results,'SI_probabilities.pdf', sep = ""), 16, 9)
  print(proba_dist_plot)
  dev.off() 
}
```



## Figure SI_probabilities_community
```{r}
proba_dist_community_plot <- test_data %>%
  mutate(class = ifelse(y_true >= 0.5, "Subsampled Links", "Non-existing Links")) %>%
  ggplot(aes(x = y_proba, fill = class)) +
    geom_density(alpha = 0.5) +
    # geom_histogram(binwidth = 0.05, color = "white", alpha = 0.5, position = 'identity') +
    geom_vline(aes(xintercept = 0.5), color = "red", linetype = "dashed") +
    labs(x = "Probability", y = "Density") +
    scale_fill_manual(values = c("Non-existing Links" = "steelblue", "Subsampled Links" = "orange"), labels = labels_mapping) +
    facet_wrap(~ community, labeller = as_labeller(labels_mapping)) +
    paper_figs_theme +
    theme(legend.title = element_blank(),
          axis.text.x=element_text(angle=-45, hjust=0))
if(export){
  pdf(paste(path_final_results,'SI_probabilities_community.pdf', sep = ""), 16, 9)
  print(proba_dist_community_plot)
  dev.off()  
}
```



## Figure SI_cross_community
```{r}
metrics_type_df_long_all_metrics <- 
  metrics_type_df_long %>% 
  filter(color=='ecological') %>% 
  mutate(type_train=gsub("\\['|'\\]", "", type_train)) %>% 
  mutate(type_test=gsub("\\['|'\\]", "", type_test))

metrics_type_df_long_all_metrics$type_train[metrics_type_df_long_all_metrics$type_train=="Plant-Seed Dispersers', 'Plant-Pollinator', 'Plant-Herbivore', 'Host-Parasite"] <- 'All'
metrics_type_df_long_all_metrics$type_train <- factor(metrics_type_df_long_all_metrics$type_train, levels = c('All', names(communities_colors)))
metrics_type_df_long_all_metrics$type_test[metrics_type_df_long_all_metrics$type_test=="Plant-Seed Dispersers', 'Plant-Pollinator', 'Plant-Herbivore', 'Host-Parasite"] <- 'All'
metrics_type_df_long_all_metrics$type_test <- factor(metrics_type_df_long_all_metrics$type_test, levels = c('All', names(communities_colors)))

abbr_mapping <- c(
  "Plant-Seed Dispersers" = "PSD",
  "Plant-Pollinator" = "PP",
  "Plant-Herbivore" = "PH",
  "Host-Parasite" = "HP",
  "All" = "All"
)

# Apply the abbreviations to the data
metrics_type_df_long_all_metrics <- metrics_type_df_long_all_metrics %>%
  mutate(type_train = abbr_mapping[type_train],
         type_test = abbr_mapping[type_test])

cross_community_all_metrics <-   
  metrics_type_df_long_all_metrics %>%
  group_by(metric, type_train, type_test) %>%
  summarise(m = median(value, na.rm = TRUE)) %>%
  mutate(diagonal = ifelse(type_train == type_test, "Diagonal", "Non-Diagonal")) %>%
  ggplot(aes(x = type_train, y = type_test, fill = m)) +
  geom_tile(color='white', lwd = 1.5, linetype = 1) +
  scale_fill_viridis_c() +
  # coord_fixed() +
  paper_figs_theme +
  geom_tile(data = . %>% filter(diagonal == "Diagonal"), color = '#C66AC4', lwd = 3, linetype = 1, size = 3) +
  labs(y = "Test community", x = "Train community") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))+
  geom_richtext(aes(label = round(m, 2)),
                fill = 'white',
                label.padding = unit(0.1, "lines"),
                text.colour = "black",
                fontface = "bold",
                label.colour = "black")+
  facet_wrap(vars(metric), scales = 'free')

# Try with patchworks
library(patchwork)

# Assuming metrics_type_df_long_all_metrics is already loaded

# Create a list of individual plots for each metric
plots <- metrics_type_df_long_all_metrics %>%
  group_by(metric, type_train, type_test) %>%
  summarise(m = median(value, na.rm = TRUE)) %>%
  mutate(diagonal = ifelse(type_train == type_test, "Diagonal", "Non-Diagonal")) %>%
  ungroup() %>% 
  group_split(metric) %>%
  map(function(df) {
    ggplot(df, aes(x = type_train, y = type_test, fill = m)) +
      geom_tile(color='white', lwd = 1.5, linetype = 1) +
      scale_fill_viridis_c() +
      coord_fixed() +
      labs(y = "Test community", x = "Train community", title = unique(df$metric)) +
      theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
      geom_richtext(aes(label = round(m, 2)),
                    fill = 'white',
                    label.padding = unit(0.1, "lines"),
                    text.colour = "black",
                    fontface = "bold",
                    label.colour = "black")
      # geom_tile(data = df %>% filter(diagonal == "Diagonal"), color = '#C66AC4', lwd = 3, linetype = 1, size = 3) +
  })

# Combine the individual plots into one
combined_plot <- wrap_plots(plots)

# Print the combined plot
print(combined_plot)

# cross_community_all_metrics <-   
#   ggplot(metrics_type_df_long_all_metrics, aes(x = type_train, y = value, fill=type_train)) +
#   geom_boxplot() +
#   paper_figs_theme +
#   # scale_y_continuous(breaks = c(0,0.25,0.5,1)) +
#   scale_fill_manual(values=c('orange',unname(communities_colors)))+
#   # stat_summary(fun = mean, geom = "point", shape = 18, size = 4, color = "black", show.legend=F) +
#   labs(y = "Metric value", fill = "Training community") +
#   theme(legend.position = 'bottom',
#         axis.title.x = element_blank(),
#         axis.text.x = element_blank(),
#         axis.ticks = element_blank(),
#         strip.text = element_text(size = 14))+
#   facet_grid(
#     cols = vars(type_test),
#     rows = vars(metric),
#     labeller = labeller(
#       type_test = function(labels) custom_labeler(labels, "type_test")
#     ), scales = 'free_y'
#   )

print(cross_community_all_metrics)

if(export){
  pdf(paste(path_final_results,'SI_cross_community.pdf', sep = ""), 10, 6)
  print(cross_community_all_metrics)
  dev.off()
}
```




# Tables

### Helper functions
```{r}
# Function to format p-values
format_pvalue <- function(x) { 
  sapply(x, function(y) {
    if (is.na(y)) {
      return(NA)
    } else if (y < 1e-4) { # Adjust this threshold as needed
      return(formatC(y, format = "e", digits = 2))
    } else {
      return(round(y, 4)) # Adjust the number of decimal places as needed
    }
  })
}

# Rename function
rename_underscore <- function(old_name) {
  new_name <- str_replace_all(old_name, "_", " ") # underscore ('_') cause problems in latex
  new_name <- str_replace_all(new_name, "\\.", " ")
  return(new_name)
}

# List of escape characters for latex
latex_escapes <- c( 
  "#"  = "\\#",
  "$"  = "\\$",
  "%"  = "\\%",
  "&"  = "\\&",
  "_"  = "\\_",
  "{"  = "\\{",
  "}"  = "\\}",
  "~"  = "\\textasciitilde{}",
  "^"  = "\\textasciicircum{}"
  # "\\" = "\\textbackslash{}"
)

# Escape special characters in LaTeX
escape_latex <- function(string) {
  reduce(names(latex_escapes), function(str, char) {
    str_replace_all(str, fixed(char), latex_escapes[char])
  }, .init = string)
}

```

### Kruskal Wallis test #1 - comparing metrics of different communities
```{r}

# Count the total number of tests to performed
total_tests <- length(unique(metrics_df_long$community)) # should be the number of communities

kruskal_dunn_df_comm <- metrics_df_long %>%
  group_by(metric) %>%
  summarise(
    test = list(kruskal.test(value ~ community)),
    .groups = 'drop'
  ) %>%
  mutate(
    chi_squared = sapply(test, function(x) round(x$statistic, 3)), # Round the chi-squared values
    p_value = sapply(test, function(x) x$p.value),
  ) %>% 
  mutate( # Format the p-values
    p_value = format_pvalue(p_value),
  ) %>%
  select(-test) %>%
  rowwise() %>%
  mutate(
    dunn_test = if(as.numeric(p_value) < 0.05) list(dunn.test(metrics_type_df_long_mcc_f1$value, metrics_type_df_long_mcc_f1$type_train, method="bonferroni")) else list(NULL)
  ) %>%
  ungroup()

# Kruskal-Wallis tests summary
kruskal_df_comm <- kruskal_dunn_df_comm %>%
  select(-'dunn_test')

# Post-hoc Dunn tests
dunn_df_comm = data.frame()
for (i in 1:nrow(kruskal_dunn_df_comm)){
  x = kruskal_dunn_df_comm$dunn_test[[i]]
  if (!is.null(x)) {
    dunn_df_subset = cbind.data.frame(x$comparisons,x$chi2,x$Z,x$P,x$P.adjusted)
    colnames(dunn_df_subset) = c('community_test_pair','chi2','Z','P','adj.P')
    dunn_df_subset$metric = kruskal_dunn_df_comm$metric[[i]]
    dunn_df_subset <- dunn_df_subset %>% relocate(metric) # move the metric column to the front
    dunn_df_comm = rbind(dunn_df_comm,dunn_df_subset)
  }
}


# A detailed comparison of the differences:
medians <- 
  metrics_df_long %>% 
  group_by(metric,community) %>% 
  summarise(metric_median=median(value, na.rm=T))


# Filter out rows with 'All' in community_test_pair
dunn_df_comm_filtered <- dunn_df_comm %>%
  filter(!str_detect(community_test_pair, "All"))

# Merge medians with the Dunn posthoc test results
combined_df <- 
  dunn_df_comm_filtered %>%
  separate(community_test_pair, into = c("Community_1", "Community_2"), sep = " - ") %>%
  left_join(medians, by = c("metric" = "metric", "Community_1" = "community")) %>%
  rename(median_1 = metric_median) %>%
  left_join(medians, by = c("metric" = "metric", "Community_2" = "community")) %>%
  rename(median_2 = metric_median) %>%
  select(metric, Community_1, Community_2, median_1, median_2, chi2, adj.P) %>% 
  arrange(metric, Community_1, Community_2)

# Rename columns appropriately
colnames(combined_df) <- c("Metic","Community 1", "Community 2", "Median 1", "Median 2", "Z", "P_adjusted")


# Save to file
if (export){
  write.csv(kruskal_df_comm, file = paste0(path_final_results, "SI_KW_communities.csv"), row.names = FALSE)
  write.csv(combined_df, file = paste0(path_final_results, "SI_KW_communities_Dunn.csv"), row.names = FALSE)
}
```


### Kruskal Wallis test #2 - comparing metrics of cross communities prediction

```{r}
# Count the total number of tests to performed
total_tests <- length(unique(metrics_type_df_long_mcc_f1$type_test)) # should be the number of communities

# Perform Kruskal-Wallis tests for each metric and type_test combination
kruskal_dunn_df_cross <- 
  metrics_type_df_long_mcc_f1 %>%
  group_by(metric, type_test) %>%
  summarise(
    test = list(kruskal.test(value ~ type_train)),
    .groups = 'drop'
  ) %>%
  mutate(
    chi_squared = sapply(test, function(x) round(x$statistic, 3)), # Round the chi-squared values
    p_value = sapply(test, function(x) x$p.value),
    # p_value_bonf = p_value * total_tests, # Apply the Bonferroni correction to the p-values
  ) %>% 
  mutate( # Format the p-values
    p_value = format_pvalue(p_value),
    # p_value_bonf = format_pvalue(p_value_bonf)
  ) %>%
  mutate(type_test=gsub("\\['|'\\]", "", type_test)) %>%
  mutate(type_test=ifelse(type_test=="Plant-Seed Dispersers', 'Plant-Pollinator', 'Plant-Herbivore', 'Host-Parasite",'All',type_test)) %>%
  select(-test) %>%
  rowwise() %>%
  mutate(
    dunn_test = if(as.numeric(p_value) < 0.05) list(dunn.test(metrics_type_df_long_mcc_f1$value, metrics_type_df_long_mcc_f1$type_train, method="bonferroni")) else list(NULL)
  ) %>%
  ungroup()

# Kruskal-Wallis tests summary
kruskal_df_cross <- kruskal_dunn_df_cross %>%
  select(-'dunn_test')

# Post-hoc Dunn tests
dunn_df_cross = data.frame()
for (i in 1:nrow(kruskal_dunn_df_cross)){
  x = kruskal_dunn_df_cross$dunn_test[[i]]
  if (!is.null(x)) {
    dunn_df_subset = cbind.data.frame(x$comparisons,x$chi2,x$Z,x$P,x$P.adjusted)
    colnames(dunn_df_subset) = c('community_train_pair','chi2','Z','P','adj.P')
    dunn_df_subset$community_test = kruskal_dunn_df_cross$type_test[[i]]
    dunn_df_subset$metric = kruskal_dunn_df_cross$metric[[i]]
    dunn_df_subset <- dunn_df_subset %>% relocate(community_test) # move the community_test column to the front
    dunn_df_subset <- dunn_df_subset %>% relocate(metric, .after = community_train_pair)
    dunn_df_cross = rbind(dunn_df_cross,dunn_df_subset)
  }
}

# A detailed comparison of the differences:
# Remove all \n from comm_names
clean_comm_names <- sapply(comm_names, function(x) gsub("\n", "", x), USE.NAMES = TRUE)

# Convert clean_comm_names to a tibble
comm_names_df <- enframe(clean_comm_names, name = "type_test", value = "label")

medians <- 
  metrics_type_df_long_mcc_f1 %>% 
  group_by(metric, type_test, type_train) %>% 
  summarise(metric_median=median(value, na.rm=T)) %>% 
  left_join(comm_names_df, by = c("type_test" = "type_test")) %>%
  mutate(type_test = ifelse(label == "All\nEcological", "All", label)) %>%
  select(-label) %>% 
  as_tibble()

medians$type_test
dunn_df_cross$community_test

# Merge medians with the Dunn posthoc test results
combined_df <- 
  as_tibble(dunn_df_cross) %>%
  separate(community_train_pair, into = c("Community_1", "Community_2"), sep = " - ") %>%
  left_join(medians, by = c("metric" = "metric","community_test"="type_test", "Community_1" = "type_train")) %>%
  rename(median_1 = metric_median) %>%
  left_join(medians, by = c("community_test"="type_test","metric" = "metric", "Community_2" = "type_train")) %>%
  rename(median_2 = metric_median) %>%
  select(metric, community_test, Community_1, Community_2, median_1, median_2, Z, adj.P) %>% 
  arrange(metric, community_test, Community_1, Community_2)

# Rename columns appropriately
colnames(combined_df) <- c("Metic","Testing community","Training community 1", "Training community 2", "Median 1", "Median 2", "Z", "P_adjusted")


# Save to file
if (export){
  write.csv(kruskal_df_cross, file = paste0(path_final_results, "SI_KW_cross.csv"), row.names = FALSE)
  write.csv(combined_df, file = paste0(path_final_results, "SI_KW_cross_Dunn.csv"), row.names = FALSE)
}
```

### Networks table
```{r eval=FALSE, include=FALSE}

# Load the dataframe
network_lvl_features <- read.csv(paste0(path_intermediate_results, "network_lvl_features.csv"))

# Create a table of the networks general information
networks_table <- network_lvl_features %>%
  select(name, community, network_size, interactions_count, connectance) %>%
  filter(community %in% c("Host-Parasite", "Plant-Pollinator", "Plant-Seed Dispersers", "Plant-Herbivore")) %>%
  arrange(name) %>%
  mutate(
    non_interactions_count = network_size^2 - interactions_count,
    connectance = round(connectance, 2),
    name = map_chr(name, escape_latex),
  )

if (export){
  write.csv(networks_table, file = paste0(path_final_results, "networks_table.csv"), row.names = FALSE)
}
```


### Summary properties table

```{r eval=FALSE, include=FALSE}
# Load the dataframe
# networks_table <- read.csv(paste0(path_final_results, "networks_table.csv"))

# Alter names for the properties
properties_name_mapper <- c(
  "N" = "network size",
  "L_e" = "interactions count",
  "L_ne" = "non interactions count",
  "C" = "connectance")

# Order of the properties
properties_order <- names(properties_name_mapper)

# Function to add math style to the string
math_style <- function(string) {
  return(paste0("$", string, "$"))
}

# Calculate the summary properties	
summary_table <- networks_table %>%
  rename_with(.fn =  rename_underscore) %>%
  rename(!!!properties_name_mapper) %>%
  # pivot_longer(cols = -c(name, community, Reference), names_to = "variable", values_to = "value") %>% # Convert to long format
  pivot_longer(cols = -c(name, community), names_to = "variable", values_to = "value") %>% # Convert to long format
  group_by(variable, community) %>%
  summarize( # Create a summary table
    Mean = round(mean(value, na.rm = TRUE), 2), 
    Min = min(value, na.rm = TRUE),	
    Q1 = quantile(value, 0.25, na.rm = TRUE),	
    Median = median(value, na.rm = TRUE),	
    Q3 = quantile(value, 0.75, na.rm = TRUE),	
    Max = max(value, na.rm = TRUE),
    Range = paste0(round(Min, 2), "-", round(Max, 2))
  ) %>%
  arrange(factor(variable, levels = properties_order), community) %>% # Arrange by variable then community
  mutate(variable = map_chr(variable, math_style),) # Escape special characters in LaTeX
  
# Print the summary table
print(summary_table)

if (export){
  write.csv(summary_table, file = paste0(path_final_results, "SI_networks_summary_properties.csv"), row.names = FALSE)
}
```